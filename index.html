<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRUIT CRUSH - Match 3 Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;700&display=swap');
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
    font-family: 'Fredoka One', cursive, 'Inter', sans-serif;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    color: #e0e6f1;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 16px;
    overflow-x: hidden;
    user-select: none;
  }
  h1 {
    font-weight: 700;
    font-size: 2.5rem;
    margin-bottom: 16px;
    background: linear-gradient(45deg, #8b5cf6, #06b6d4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    user-select: none;
    text-shadow: 2px 2px 8px rgba(0,0,0,0.6);
  }
  .game-container {
    background: rgba(255 255 255 / 0.05);
    border-radius: 20px;
    padding: 24px;
    width: 100%;
    max-width: 480px;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    box-shadow: 0 8px 40px rgb(139 92 246 / 0.5);
    position: relative;
  }
  .status-bar {
    width: 100%;
    display: flex;
    justify-content: space-around;
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 24px;
    font-family: 'Fredoka One', cursive;
    gap: 14px;
    flex-wrap: wrap;
  }
  .status-item {
    background: rgba(255 255 255 / 0.15);
    border-radius: 14px;
    padding: 12px 18px;
    min-width: 110px;
    text-align: center;
    box-shadow: 0 5px 14px rgba(11, 16, 22, 0.35);
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #e0e6f1;
  }
  .status-label {
    font-size: 0.8rem;
    color: #bbbbcc;
    margin-bottom: 3px;
    user-select: none;
  }
  .status-value {
    font-size: 1.5rem;
    font-weight: 800;
    letter-spacing: 1.2px;
    user-select: none;
  }
  #grid {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 8px;
    margin-bottom: 24px;
  }
  .cell {
    background: #2a3152;
    border-radius: 14px;
    box-shadow: inset 0 0 12px rgba(255 255 255 / 0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    cursor: pointer;
    user-select: none;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    will-change: transform;
    position: relative;
  }
  .cell[data-color="0"] { color: #ff4b5c; }
  .cell[data-color="1"] { color: #ffd662; }
  .cell[data-color="2"] { color: #4cd137; }
  .cell[data-color="3"] { color: #2980b9; }
  .cell[data-color="4"] { color: #9b59b6; }
  .cell[data-color="5"] { color: #e67e22; }
  .cell.selected {
    outline: 4px solid #8b5cf6;
    transform: scale(1.15);
    box-shadow: 0 0 18px #8b5cf6;
    z-index: 10;
  }
  /* Gaya untuk bonus */
  .cell.bonus-row {
    border: 3px solid #06b6d4;
    box-shadow: 0 0 15px #06b6d4;
  }
  .cell.bonus-column {
    border: 3px solid #8b5cf6;
    box-shadow: 0 0 15px #8b5cf6;
  }
  .cell.bonus-bomb {
    border: 3px solid #ff4b5c;
    box-shadow: 0 0 15px #ff4b5c;
    transform: rotate(5deg);
  }
  .cell.bonus-color-bomb {
    background: radial-gradient(circle, #f06, #a0c); /* Contoh gaya */
    box-shadow: 0 0 20px #f06, inset 0 0 10px #fff;
    border: 2px solid #fff;
    transform: rotate(15deg); /* Contoh animasi */
  }

  button {
    background: #8b5cf6;
    color: white;
    border: none;
    border-radius: 16px;
    padding: 14px 28px;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 22px rgba(139, 92, 246, 0.9);
    transition: background-color 0.3s ease;
    margin: 6px;
    min-width: 110px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.15rem;
  }
  button:hover:not(:disabled) {
    background: #06b6d4;
    box-shadow: 0 0 32px #06b6d4;
  }
  button:disabled {
    background: #444c5c;
    cursor: not-allowed;
    box-shadow: none;
    color: #999;
  }
  .controls {
    width: 100%;
    display: flex;
    justify-content: space-around;
    gap: 16px;
    margin-bottom: 20px;
  }
  #message {
    font-weight: 700;
    font-size: 1.3rem;
    min-height: 36px;
    color: #00ff90;
    user-select: none;
    text-align: center;
    font-family: 'Fredoka One', cursive;
    padding: 0 16px;
    transition: opacity 0.5s ease;
  }
  .music-control {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    transition: background-color 0.3s ease;
  }
  .music-control:hover {
    background: rgba(255, 255, 255, 0.2);
  }
  .music-control .material-icons {
    color: #e0e6f1;
    font-size: 24px;
  }

  @media (max-width: 480px) {
    h1 {
      font-size: 1.8rem;
      margin-bottom: 10px;
    }
    .status-bar {
      font-size: 0.95rem;
      gap: 10px;
      flex-wrap: wrap;
    }
    .status-item {
      min-width: 80px;
      padding: 8px 12px;
    }
    .status-label {
      font-size: 0.65rem;
    }
    .status-value {
      font-size: 1.1rem;
    }
    #grid {
      gap: 6px;
    }
    .cell {
      font-size: 24px;
      border-radius: 12px;
    }
    button {
      min-width: 90px;
      padding: 12px 20px;
      font-size: 1rem;
    }
    #message {
      font-size: 1.1rem;
      min-height: 32px;
    }
    .music-control {
      top: 10px;
      right: 10px;
      width: 35px;
      height: 35px;
    }
    .music-control .material-icons {
      font-size: 20px;
    }
  }
</style>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
</head>
<body>
<h1>FRUIT CRUSH</h1>
<div class="game-container" role="main" aria-label="game grid area">
  <div class="status-bar" aria-live="polite" aria-atomic="true">
    <div class="status-item" id="levelIndicator">
      <div class="status-label">LEVEL</div>
      <div class="status-value">1</div>
    </div>
    <div class="status-item" id="targetScoreIndicator">
      <div class="status-label">TARGET SKOR</div>
      <div class="status-value">500</div>
    </div>
    <div class="status-item" id="scoreIndicator">
      <div class="status-label">SKOR</div>
      <div class="status-value">0</div>
    </div>
    <div class="status-item" id="timeIndicator">
      <div class="status-label">GERAKAN</div> <!-- Label diubah dari WAKTU ke GERAKAN -->
      <div class="status-value">25 moves</div> <!-- Nilai awal gerakan -->
    </div>
  </div>
  <div id="grid" aria-label="Game board" tabindex="0"></div>
  <div class="controls">
    <button id="startBtn" aria-label="Mulai Permainan" title="Mulai Permainan">
      <span class="material-icons" aria-hidden="true">play_arrow</span> Mulai
    </button>
    <button id="pauseBtn" aria-label="Jeda Permainan" title="Jeda Permainan" disabled>
      <span class="material-icons" aria-hidden="true">pause</span> Jeda
    </button>
    <button id="retryBtn" aria-label="Ulang Level" title="Ulang Level" disabled>
      <span class="material-icons" aria-hidden="true">replay</span> Ulang
    </button>
  </div>
  <div id="message" role="alert" aria-live="assertive"></div>
</div>

<!-- Elemen Audio untuk Musik Latar -->
<audio id="backgroundMusic" loop>
  <source src="https://www.bensound.com/bensound-music/bensound-ukulele.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>

<!-- Elemen Audio untuk Efek Suara -->
<audio id="swapSound" src="https://www.soundjay.com/buttons/sounds/button-1.mp3"></audio>
<audio id="matchSound" src="https://www.soundjay.com/buttons/sounds/button-2.mp3"></audio>
<audio id="bonusSound" src="https://www.soundjay.com/buttons/sounds/button-3.mp3"></audio>
<audio id="gameOverSound" src="https://www.soundjay.com/misc/sounds/fail-buzzer-01.mp3"></audio>
<audio id="levelUpSound" src="https://www.soundjay.com/misc/sounds/success-fanfare-01.mp3"></audio>

<!-- Tombol Kontrol Musik -->
<div class="music-control" id="musicControlBtn" aria-label="Kontrol Musik">
  <span class="material-icons" id="musicIcon">music_note"></span>
</div>

<script>
(() => {
  'use strict';

  const ROWS = 8;
  const COLS = 8;
  const BASE_MOVES = 25; // Gerakan dasar
  const MAX_LEVEL = 100;
  const COLOR_SETS = [3,4,4,4,5,5,5,6,6,6]; // Jumlah warna per level
  const ITEM_SHAPES = ['ðŸ’', 'ðŸ‹', 'ðŸ¥', 'ðŸ‡', 'ðŸ“', 'ðŸŠ']; // Bentuk item

  const BONUS_TYPES = {
    NONE: 'none',
    ROW: 'bonus-row', // Dibuat dari 4 item horizontal
    COLUMN: 'bonus-column', // Dibuat dari 4 item vertikal
    BOMB: 'bonus-bomb', // Dibuat dari 5 item T/L
    COLOR_BOMB: 'bonus-color-bomb' // Dibuat dari 5 item lurus
  };

  const gridElement = document.getElementById('grid');
  const levelIndicator = document.getElementById('levelIndicator');
  const scoreIndicator = document.getElementById('scoreIndicator');
  const targetScoreIndicator = document.getElementById('targetScoreIndicator');
  const movesIndicator = document.getElementById('timeIndicator'); // Menggunakan elemen waktu untuk gerakan
  const messageElement = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const retryBtn = document.getElementById('retryBtn');

  // Elemen Musik
  const backgroundMusic = document.getElementById('backgroundMusic');
  const musicControlBtn = document.getElementById('musicControlBtn');
  const musicIcon = document.getElementById('musicIcon');

  // Elemen Efek Suara
  const swapSound = document.getElementById('swapSound');
  const matchSound = document.getElementById('matchSound');
  const bonusSound = document.getElementById('bonusSound');
  const gameOverSound = document.getElementById('gameOverSound');
  const levelUpSound = document.getElementById('levelUpSound');

  let level = 1;
  let score = 0;
  let moves = BASE_MOVES;
  let maxMoves = BASE_MOVES;
  let isPaused = false;
  let selectedCell = null;
  let isAnimating = false;
  let detailedGrid = []; // Menyimpan data warna dan bonus untuk setiap sel
  let isMusicPlaying = false; // Status musik

  let targetCollect = {}; // {color: amount}
  let currentCollected = {}; // {color: amount}

  const delay = ms => new Promise(res => setTimeout(res, ms));
  const idx = (r,c) => r * COLS + c; // Fungsi bantu untuk mendapatkan indeks 1D dari koordinat 2D

  function getRandomInt(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Fungsi untuk memainkan efek suara
  function playSound(audioElement) {
    if (audioElement) {
      audioElement.currentTime = 0; // Reset audio jika sedang diputar
      audioElement.play().catch(e => console.warn("Audio play failed:", e));
    }
  }

  // Inisialisasi grid dengan item acak
  function initGrid(){
    const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
    detailedGrid = [];
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        detailedGrid[idx(r,c)] = {
          color: getRandomInt(0, colorCount - 1),
          bonus: BONUS_TYPES.NONE
        };
      }
    }
    removeInitialMatches(); // Pastikan tidak ada kecocokan di awal
  }

  // Hapus kecocokan awal yang mungkin terjadi saat inisialisasi grid
  function removeInitialMatches(){
    const matches = findMatches();
    if(matches.length > 0){
      matches.forEach(i => detailedGrid[i].color = getRandomInt(0, (level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6) - 1));
      removeInitialMatches(); // Rekursif sampai tidak ada kecocokan
    }
  }

  // Render grid ke DOM
  function renderGrid(){
    gridElement.innerHTML = '';
    gridElement.style.pointerEvents = isAnimating ? 'none' : 'auto'; // Nonaktifkan interaksi saat animasi
    for(let i=0; i<detailedGrid.length; i++){
      const cellData = detailedGrid[i];
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      cell.dataset.color = cellData.color;
      if(cellData.bonus && cellData.bonus !== BONUS_TYPES.NONE) {
        cell.classList.add(cellData.bonus); // Tambahkan kelas bonus jika ada
      }
      if(selectedCell === i) cell.classList.add('selected'); // Tandai sel yang dipilih
      cell.textContent = ITEM_SHAPES[cellData.color]; // Tampilkan bentuk item
      cell.setAttribute('tabindex','0');
      cell.setAttribute('role','button');
      let bonusText = cellData.bonus !== BONUS_TYPES.NONE ? `, bonus ${cellData.bonus.replace('bonus-', '')}` : "";
      cell.setAttribute('aria-label', `Item warna nomor ${cellData.color + 1}${bonusText}`);
      cell.onclick = () => onCellClicked(i);
      gridElement.appendChild(cell);
    }
  }

  // Cek apakah dua sel berdekatan
  function isAdjacent(a, b){
    const r1 = Math.floor(a/COLS), c1 = a%COLS;
    const r2 = Math.floor(b/COLS), c2 = b%COLS;
    return (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
  }

  // Handler saat sel diklik
  async function onCellClicked(index){
    if(isAnimating || isPaused) return; // Tidak bisa berinteraksi saat animasi atau jeda
    if(selectedCell === null){
      selectedCell = index;
    } else {
      if(selectedCell === index){
        selectedCell = null; // Batalkan pilihan jika sel yang sama diklik lagi
      } else if(isAdjacent(selectedCell, index)){
        await swapAndCheck(selectedCell, index); // Tukar dan cek kecocokan
        selectedCell = null;
      } else {
        selectedCell = index; // Pilih sel baru
      }
    }
    renderGrid();
  }

  // Tukar posisi dua sel dalam detailedGrid
  function swapCells(a,b){
    [detailedGrid[a], detailedGrid[b]] = [detailedGrid[b], detailedGrid[a]];
  }

  // Tukar sel dan cek kecocokan
  async function swapAndCheck(a,b){
    isAnimating = true; // Setel ke true di awal
    const cellA = detailedGrid[a];
    const cellB = detailedGrid[b];

    let specialMatch = false;
    let colorToClear = -1;
    let matchesFound = false; // Flag untuk menandai apakah ada kecocokan atau bonus yang diaktifkan

    // Logika untuk bonus warna saat ditukar dengan item normal
    if (cellA.bonus === BONUS_TYPES.COLOR_BOMB && cellB.bonus === BONUS_TYPES.NONE) {
      specialMatch = true;
      colorToClear = cellB.color;
    } else if (cellB.bonus === BONUS_TYPES.COLOR_BOMB && cellA.bonus === BONUS_TYPES.NONE) {
      specialMatch = true;
      colorToClear = cellA.color;
    }
    // Logika untuk pertukaran dua bonus
    else if (cellA.bonus !== BONUS_TYPES.NONE && cellB.bonus !== BONUS_TYPES.NONE) {
        specialMatch = true;
        colorToClear = 'ALL';
    }

    swapCells(a,b); // Lakukan pertukaran di data grid
    renderGrid(); // Perbarui tampilan
    playSound(swapSound);
    await delay(300);

    if (specialMatch) {
      matchesFound = true; // Bonus diaktifkan
      const indicesToClear = new Set();
      if (colorToClear === 'ALL') {
          for (let i = 0; i < detailedGrid.length; i++) {
              indicesToClear.add(i);
          }
      } else {
          for (let i = 0; i < detailedGrid.length; i++) {
              if (detailedGrid[i].color === colorToClear) {
                  indicesToClear.add(i);
              }
          }
      }
      indicesToClear.add(a);
      indicesToClear.add(b);

      await processSpecialMatches(Array.from(indicesToClear));
    } else {
      const matches = findMatches();
      if(matches.length > 0){
        matchesFound = true; // Kecocokan ditemukan
        await processMatches(matches);
      } else {
        // Jika tidak ada kecocokan, kembalikan dan reset isAnimating
        swapCells(a,b);
        renderGrid();
        isAnimating = false; // Reset di sini jika tidak ada kecocokan
      }
    }

    // Kurangi gerakan hanya jika ada kecocokan atau bonus yang diaktifkan
    if (matchesFound) {
        moves--;
        movesIndicator.querySelector('.status-value').textContent = `${moves} moves`;
        if (moves <= 0) {
            gameOver();
        }
    }
    // isAnimating sudah direset di akhir processMatches/processSpecialMatches atau di blok else di atas
  }

  // Cari kecocokan (3 atau lebih item yang sama) di grid
  function findMatches(){
    const matchesSet = new Set(); // Set untuk menyimpan indeks sel yang cocok
    const bonusCandidates = []; // Array untuk menyimpan kandidat bonus

    // Cek kecocokan horizontal
    for(let r = 0; r < ROWS; r++){
      let chainStart = 0;
      for(let c = 1; c <= COLS; c++){
        if(c < COLS && detailedGrid[idx(r,c)].color === detailedGrid[idx(r,chainStart)].color) continue;
        const length = c - chainStart;
        if(length >= 3){
          for(let k = chainStart; k < c; k++) matchesSet.add(idx(r,k));
          if(length === 4){ // Bonus Baris (Striped Candy)
            const bonusPos = idx(r, Math.floor((chainStart + c - 1) / 2));
            bonusCandidates.push({pos: bonusPos, type: 'row_bonus'});
          } else if (length >= 5) { // Bonus Warna (Color Bomb)
            const bonusPos = idx(r, Math.floor((chainStart + c - 1) / 2));
            bonusCandidates.push({pos: bonusPos, type: 'color_bomb'});
          }
        }
        chainStart = c;
      }
    }

    // Cek kecocokan vertikal
    for(let c = 0; c < COLS; c++){
      let chainStart = 0;
      for(let r = 1; r <= ROWS; r++){
        if(r < ROWS && detailedGrid[idx(r,c)].color === detailedGrid[idx(chainStart,c)].color) continue;
        const length = r - chainStart;
        if(length >= 3){
          for(let k = chainStart; k < r; k++) matchesSet.add(idx(k,c));
          if(length === 4){ // Bonus Kolom (Striped Candy)
            const bonusPos = idx(Math.floor((chainStart + r - 1) / 2), c);
            bonusCandidates.push({pos: bonusPos, type: 'column_bonus'});
          } else if (length >= 5) { // Bonus Warna (Color Bomb)
            const bonusPos = idx(Math.floor((chainStart + r - 1) / 2), c);
            bonusCandidates.push({pos: bonusPos, type: 'color_bomb'});
          }
        }
        chainStart = r;
      }
    }

    // Cek kecocokan bentuk 'T' atau 'L' untuk Bonus Bomb (Wrapped Candy)
    // Ini adalah implementasi sederhana, mungkin tidak mencakup semua orientasi.
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const color = detailedGrid[idx(r, c)].color;
            if (color === -1) continue; // Skip empty cells

            // Bentuk T (horizontal)
            //   X X X
            //     X
            if (c + 2 < COLS && r + 1 < ROWS &&
                detailedGrid[idx(r, c + 1)].color === color &&
                detailedGrid[idx(r, c + 2)].color === color &&
                detailedGrid[idx(r + 1, c + 1)].color === color) {
                // Pastikan semua sel yang membentuk T adalah bagian dari matchesSet
                if (matchesSet.has(idx(r, c)) && matchesSet.has(idx(r, c + 1)) && matchesSet.has(idx(r, c + 2)) && matchesSet.has(idx(r + 1, c + 1))) {
                    bonusCandidates.push({ pos: idx(r, c + 1), type: 'bomb_bonus' }); // Posisi tengah T
                }
            }
            // Bentuk T (vertikal)
            //   X
            //   X X
            //   X
            if (r + 2 < ROWS && c + 1 < COLS &&
                detailedGrid[idx(r + 1, c)].color === color &&
                detailedGrid[idx(r + 2, c)].color === color &&
                detailedGrid[idx(r + 1, c + 1)].color === color) {
                if (matchesSet.has(idx(r, c)) && matchesSet.has(idx(r + 1, c)) && matchesSet.has(idx(r + 2, c)) && matchesSet.has(idx(r + 1, c + 1))) {
                    bonusCandidates.push({ pos: idx(r + 1, c), type: 'bomb_bonus' }); // Posisi tengah T
                }
            }
            // Bentuk L (atas kiri)
            // X
            // X
            // X X X
            if (r + 2 < ROWS && c + 2 < COLS &&
                detailedGrid[idx(r + 1, c)].color === color &&
                detailedGrid[idx(r + 2, c)].color === color &&
                detailedGrid[idx(r + 2, c + 1)].color === color &&
                detailedGrid[idx(r + 2, c + 2)].color === color) {
                if (matchesSet.has(idx(r, c)) && matchesSet.has(idx(r + 1, c)) && matchesSet.has(idx(r + 2, c)) && matchesSet.has(idx(r + 2, c + 1)) && matchesSet.has(idx(r + 2, c + 2))) {
                    bonusCandidates.push({ pos: idx(r + 2, c), type: 'bomb_bonus' }); // Posisi sudut L
                }
            }
            // Tambahkan lebih banyak pola L/T jika diperlukan
        }
    }


    // Hapus bonus yang sudah ada di sel yang akan cocok
    matchesSet.forEach(i => { detailedGrid[i].bonus = BONUS_TYPES.NONE; });

    // Tetapkan bonus ke sel yang sesuai
    for(const bonus of bonusCandidates){
      if(matchesSet.has(bonus.pos)){ // Pastikan posisi bonus masih bagian dari kecocokan
        if(bonus.type === 'row_bonus'){
          detailedGrid[bonus.pos].bonus = BONUS_TYPES.ROW;
        } else if(bonus.type === 'column_bonus'){
          detailedGrid[bonus.pos].bonus = BONUS_TYPES.COLUMN;
        } else if(bonus.type === 'bomb_bonus'){
          detailedGrid[bonus.pos].bonus = BONUS_TYPES.BOMB;
        } else if(bonus.type === 'color_bomb'){
          detailedGrid[bonus.pos].bonus = BONUS_TYPES.COLOR_BOMB;
        }
      }
    }

    return Array.from(matchesSet);
  }

  // Proses kecocokan yang ditemukan
  async function processMatches(matched){
    if(matched.length === 0){
        isAnimating = false; // PENTING: Reset di sini jika tidak ada kecocokan yang diproses
        return;
    }

    playSound(matchSound); // Mainkan suara match

    const expandedMatches = new Set(matched); // Set untuk semua sel yang akan dihapus

    // Perluas kecocokan berdasarkan bonus yang terlibat
    matched.forEach(i => {
      const cell = detailedGrid[i];
      if(cell.bonus === BONUS_TYPES.ROW){ // Bonus Baris
        playSound(bonusSound);
        const r = Math.floor(i / COLS);
        for(let c=0; c<COLS; c++) expandedMatches.add(idx(r,c));
      } else if(cell.bonus === BONUS_TYPES.COLUMN){ // Bonus Kolom
        playSound(bonusSound);
        const c = i % COLS;
        for(let r=0; r<ROWS; r++) expandedMatches.add(idx(r,c));
      } else if(cell.bonus === BONUS_TYPES.BOMB){ // Bonus Bomb (3x3 area)
        playSound(bonusSound);
        const r = Math.floor(i / COLS);
        const c = i % COLS;
        for(let dr=-1; dr<=1; dr++){
          for(let dc=-1; dc<=1; dc++){
            const nr = r + dr, nc = c + dc;
            if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) expandedMatches.add(idx(nr,nc));
          }
        }
      } else if(cell.bonus === BONUS_TYPES.COLOR_BOMB){
          // Jika Color Bomb cocok sendiri (misalnya, 5 Color Bomb berjejer),
          // kita bisa membuatnya menghapus semua item di papan.
          playSound(bonusSound);
          for (let j = 0; j < detailedGrid.length; j++) {
              expandedMatches.add(j);
          }
      }
    });

    score += expandedMatches.size * 10; // Tambahkan skor
    scoreIndicator.querySelector('.status-value').textContent = score;

    // Hitung item yang terkumpul untuk target
    expandedMatches.forEach(i => {
        const color = detailedGrid[i].color;
        if (color !== -1) { // Pastikan bukan sel kosong
            currentCollected[color] = (currentCollected[color] || 0) + 1;
        }
    });

    // Animasi penghapusan sel
    expandedMatches.forEach(i => {
      const cell = gridElement.children[i];
      if(cell){
        cell.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
        cell.style.transform = 'scale(0)';
        cell.style.opacity = '0';
      }
    });

    await delay(400); // Tunggu animasi selesai

    // Setel sel yang dihapus ke -1 (kosong) dan hapus bonus
    expandedMatches.forEach(i => {
      detailedGrid[i].color = -1;
      detailedGrid[i].bonus = BONUS_TYPES.NONE;
    });

    dropCandies(); // Jatuhkan item di atas
    refillGrid(); // Isi ulang grid
    renderGrid(); // Perbarui tampilan

    await delay(300); // Tunggu animasi jatuh dan isi ulang

    const newMatches = findMatches(); // Cari kecocokan berantai
    if(newMatches.length > 0){
      await processMatches(newMatches); // Rekursif, isAnimating akan direset di akhir rantai
    } else{
      isAnimating = false; // PENTING: Reset di sini setelah semua rantai kecocokan selesai
      checkLevelCompletion();
    }
  }

  // Fungsi terpisah untuk memproses kecocokan khusus (misalnya dari bonus warna)
  async function processSpecialMatches(indicesToClear) {
      playSound(bonusSound); // Mainkan suara bonus
      const expandedMatches = new Set(indicesToClear);

      score += expandedMatches.size * 10;
      scoreIndicator.querySelector('.status-value').textContent = score;

      // Hitung item yang terkumpul untuk target
      expandedMatches.forEach(i => {
          const color = detailedGrid[i].color;
          if (color !== -1) {
              currentCollected[color] = (currentCollected[color] || 0) + 1;
          }
      });

      expandedMatches.forEach(i => {
          const cell = gridElement.children[i];
          if(cell){
              cell.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
              cell.style.transform = 'scale(0)';
              cell.style.opacity = '0';
          }
      });

      await delay(400);

      expandedMatches.forEach(i => {
          detailedGrid[i].color = -1;
          detailedGrid[i].bonus = BONUS_TYPES.NONE;
      });

      dropCandies();
      refillGrid();
      renderGrid();

      await delay(300);

      const newMatches = findMatches(); // Cari kecocokan berantai setelah bonus khusus
      if(newMatches.length > 0){
          await processMatches(newMatches); // Rekursif, isAnimating akan direset di akhir rantai
      } else{
          isAnimating = false; // PENTING: Reset di sini setelah semua rantai kecocokan selesai
          checkLevelCompletion();
      }
  }


  // Jatuhkan item ke bawah untuk mengisi ruang kosong
  function dropCandies(){
    for(let c=0; c<COLS; c++){
      let col = [];
      for(let r=ROWS-1; r>=0; r--){ // Iterasi dari bawah ke atas
        const cell = detailedGrid[idx(r,c)];
        if(cell.color !== -1) col.push(cell);
      }
      // Isi bagian atas kolom dengan item kosong (-1)
      while(col.length < ROWS) col.push({color: -1, bonus: BONUS_TYPES.NONE});
      // Balikkan kolom agar item yang jatuh berada di bawah
      col.reverse();
      for(let r=0; r<ROWS; r++){
        detailedGrid[idx(r,c)] = col[r];
      }
    }
  }

  // Isi ulang sel yang kosong dengan item baru
  function refillGrid(){
    const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
    for(let i=0; i<detailedGrid.length; i++){
      if(detailedGrid[i].color === -1){
        detailedGrid[i].color = getRandomInt(0, colorCount - 1);
        detailedGrid[i].bonus = BONUS_TYPES.NONE;
      }
    }
  }

  // Fungsi Game Over
  function gameOver(){
    isAnimating = true;
    playSound(gameOverSound); // Mainkan suara game over
    showMessage(`Gerakan habis! Level ${level} gagal. Silakan ulangi level ini atau mulai ulang permainan.`, true);
    pauseBtn.disabled = true;
    retryBtn.disabled = false;
    startBtn.disabled = false;
    isPaused = true;
    if (isMusicPlaying) {
        backgroundMusic.pause(); // Jeda musik saat game over
    }
  }

  // Jeda/Lanjutkan permainan
  function pauseGame(){
    if(isAnimating) return; // Tidak bisa jeda saat animasi
    isPaused = !isPaused;
    if(isPaused){
      pauseBtn.innerHTML = '<span class="material-icons" aria-hidden="true">play_arrow</span> Lanjutkan';
      showMessage("Permainan dijeda.", false);
      if (isMusicPlaying) {
          backgroundMusic.pause(); // Jeda musik saat jeda game
      }
    } else {
      pauseBtn.innerHTML = '<span class="material-icons" aria-hidden="true">pause</span> Jeda';
      showMessage("Permainan dilanjutkan.", false);
      if (isMusicPlaying) {
          backgroundMusic.play(); // Lanjutkan musik saat game dilanjutkan
      }
    }
  }

  // Cek apakah level selesai
  function checkLevelCompletion(){
    const currentTargetScore = level * 500;
    targetScoreIndicator.querySelector('.status-value').textContent = currentTargetScore;

    let scoreMet = score >= currentTargetScore;
    let collectTargetMet = true;

    // Cek target mengumpulkan item
    for (const color in targetCollect) {
        if (targetCollect.hasOwnProperty(color)) { // Pastikan properti milik objek itu sendiri
            if ((currentCollected[color] || 0) < targetCollect[color]) { // Gunakan (currentCollected[color] || 0) untuk menghindari undefined
                collectTargetMet = false;
                break;
            }
        }
    }

    if(scoreMet && collectTargetMet){
      prepareNextLevel();
    } else if (moves <= 0) { // Jika gerakan habis dan target belum tercapai
        gameOver();
    } else if (!scoreMet) {
        showMessage(`Skor kurang! Butuh ${currentTargetScore - score} lagi.`, false);
    } else if (!collectTargetMet) {
        let missingItems = [];
        for (const color in targetCollect) {
            if (targetCollect.hasOwnProperty(color)) {
                if ((currentCollected[color] || 0) < targetCollect[color]) {
                    missingItems.push(`${targetCollect[color] - (currentCollected[color] || 0)} ${ITEM_SHAPES[color]}`);
                }
            }
        }
        showMessage(`Kumpulkan ${missingItems.join(', ')} lagi!`, false);
    }
  }

  // Persiapan untuk level berikutnya
  function prepareNextLevel(){
    playSound(levelUpSound); // Mainkan suara level up
    isAnimating = true;
    maxMoves = BASE_MOVES + (level * 3); // Gerakan bertambah setiap level
    if(level % 5 === 0){ // Bonus gerakan setiap 5 level
      maxMoves += 10;
      showMessage(`Level ${level} selesai! +10 gerakan bonus! Total gerakan: ${maxMoves}. Tekan Mulai untuk lanjut level berikutnya. Target skor: ${(level + 1)*500}`, false);
    } else {
      showMessage(`Level ${level} selesai! Tekan Mulai untuk lanjut level berikutnya. Target skor: ${(level + 1)*500}`, false);
    }
    pauseBtn.disabled = true;
    retryBtn.disabled = true;
    startBtn.disabled = false;
    if (isMusicPlaying) {
        backgroundMusic.pause(); // Jeda musik saat level selesai
    }
  }

  // Mulai level berikutnya
  function startNextLevel(){
    if(level < MAX_LEVEL){
      level++;
      score = 0;
      moves = maxMoves; // Reset gerakan untuk level baru
      selectedCell = null;
      isAnimating = false;
      targetCollect = {}; // Reset target collect
      currentCollected = {}; // Reset current collected

      initGrid();
      renderGrid();
      updateButtons(true);
      updateUIElements();

      // Simpan level tertinggi yang dicapai
      localStorage.setItem('fruitCrushMaxLevel', level);

      // Tentukan target baru untuk level ini
      const targetScore = level * 500;
      targetScoreIndicator.querySelector('.status-value').textContent = targetScore;

      if (level % 3 === 0) { // Setiap 3 level, ada target mengumpulkan item
          const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
          const targetColor = getRandomInt(0, colorCount - 1);
          const targetAmount = 10 + level * 2;
          targetCollect[targetColor] = targetAmount;
          showMessage(`Level ${level} mulai! Kumpulkan ${targetAmount} ${ITEM_SHAPES[targetColor]}! Target skor: ${targetScore}`, false);
      } else {
          showMessage(`Level ${level} mulai! Selamat bermain! Target skor: ${targetScore}`, false);
      }

      if (isMusicPlaying) {
          backgroundMusic.play(); // Lanjutkan musik saat level baru dimulai
      }
    } else {
      showMessage(`Selamat! Anda menyelesaikan semua ${MAX_LEVEL} level! Skor akhir: ${score}`, false);
      pauseBtn.disabled = true;
      retryBtn.disabled = false;
      startBtn.disabled = false;
      if (isMusicPlaying) {
          backgroundMusic.pause(); // Jeda musik jika semua level selesai
      }
    }
  }

  // Perbarui elemen UI (level, skor, gerakan)
  function updateUIElements(){
    levelIndicator.querySelector('.status-value').textContent = level;
    scoreIndicator.querySelector('.status-value').textContent = score;
    movesIndicator.querySelector('.status-value').textContent = `${moves} moves`;
  }

  // Perbarui status tombol
  function updateButtons(gameStarted){
    startBtn.disabled = gameStarted;
    pauseBtn.disabled = !gameStarted;
    retryBtn.disabled = !gameStarted;
  }

  // Tampilkan pesan di layar
  function showMessage(msg, isError = false){
    messageElement.textContent = msg;
    messageElement.style.color = isError ? '#ff5555' : '#00ff90';
  }

  // Mulai permainan baru
  function startGame(){
    // Jika tombol start diklik setelah level selesai/game over, itu berarti mulai level berikutnya
    if(isAnimating && pauseBtn.disabled && retryBtn.disabled && !startBtn.disabled){
      startNextLevel();
      return;
    }
    level = 1;
    score = 0;
    maxMoves = BASE_MOVES;
    moves = maxMoves;
    isPaused = false;
    selectedCell = null;
    isAnimating = false;
    targetCollect = {};
    currentCollected = {};

    initGrid();
    renderGrid();
    updateButtons(true);
    updateUIElements();
    targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
    showMessage("Game dimulai! Selamat bermain!");
    if (isMusicPlaying) {
        backgroundMusic.play(); // Mulai musik saat game dimulai
    }
  }

  // Ulangi level saat ini
  function retryLevel(){
    score = 0;
    moves = maxMoves; // Reset gerakan ke maxMoves level saat ini
    selectedCell = null;
    isPaused = false;
    isAnimating = false;
    targetCollect = {}; // Reset target collect
    currentCollected = {}; // Reset current collected

    initGrid();
    renderGrid();
    updateButtons(true);
    updateUIElements();
    targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
    showMessage(`Level ${level} diulang! Semangat!`);
    if (isMusicPlaying) {
        backgroundMusic.play(); // Lanjutkan musik saat level diulang
    }
  }

  // Fungsi untuk mengontrol musik
  function toggleMusic() {
    if (backgroundMusic.paused) {
      backgroundMusic.play().then(() => {
        isMusicPlaying = true;
        musicIcon.textContent = 'music_note'; // Ikon musik menyala
        localStorage.setItem('musicState', 'playing');
      }).catch(error => {
        console.error("Autoplay prevented:", error);
        isMusicPlaying = false;
        musicIcon.textContent = 'music_off';
        localStorage.setItem('musicState', 'paused');
      });
    } else {
      backgroundMusic.pause();
      isMusicPlaying = false;
      musicIcon.textContent = 'music_off'; // Ikon musik mati
      localStorage.setItem('musicState', 'paused');
    }
  }

  // Navigasi keyboard untuk grid
  gridElement.addEventListener('keydown', e => {
    if(isAnimating || isPaused) return;
    const focus = document.activeElement;
    if(!focus.classList.contains('cell')) return;
    const currentIndex = Number(focus.dataset.index);
    let targetIndex = null;
    switch(e.key){
      case 'ArrowUp': if(currentIndex - COLS >= 0) targetIndex = currentIndex - COLS; break;
      case 'ArrowDown': if(currentIndex + COLS < detailedGrid.length) targetIndex = currentIndex + COLS; break;
      case 'ArrowLeft': if(currentIndex % COLS !== 0) targetIndex = currentIndex - 1; break;
      case 'ArrowRight': if(currentIndex % COLS !== COLS - 1) targetIndex = currentIndex + 1; break;
      case 'Enter':
      case ' ': onCellClicked(currentIndex); e.preventDefault(); break;
    }
    if(targetIndex !== null){
      gridElement.children[targetIndex].focus();
      e.preventDefault();
    }
  });

  // Event listener untuk tombol
  startBtn.addEventListener('click', () => startGame());
  pauseBtn.addEventListener('click', () => pauseGame());
  retryBtn.addEventListener('click', () => {
    if(confirm('Ulangi level ini? Skor dan target akan direset.')) retryLevel();
  });
  musicControlBtn.addEventListener('click', toggleMusic); // Event listener untuk tombol musik

  // Inisialisasi awal saat halaman dimuat
  updateButtons(false);
  movesIndicator.querySelector('.status-label').textContent = 'GERAKAN'; // Ubah label dari WAKTU ke GERAKAN

  // Cek level tertinggi yang disimpan
  const savedMaxLevel = localStorage.getItem('fruitCrushMaxLevel');
  if (savedMaxLevel) {
      level = parseInt(savedMaxLevel);
      maxMoves = BASE_MOVES + (level * 3); // Sesuaikan maxMoves untuk level yang dimuat
      if(level % 5 === 0) maxMoves += 10; // Tambahkan bonus jika level adalah kelipatan 5
      moves = maxMoves; // Set gerakan awal ke maxMoves
      targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
      showMessage(`Lanjutkan dari Level ${level}! Tekan Mulai.`, false);
  } else {
      targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
      showMessage("Tekan Mulai untuk bermain FRUIT CRUSH!");
  }
  updateUIElements(); // Perbarui UI dengan nilai awal

  // Cek status musik dari localStorage saat memuat
  const savedMusicState = localStorage.getItem('musicState');
  if (savedMusicState === 'playing') {
    backgroundMusic.play().then(() => {
        isMusicPlaying = true;
        musicIcon.textContent = 'music_note';
    }).catch(error => {
        console.warn("Autoplay prevented on load. Music will start after user interaction.", error);
        isMusicPlaying = false;
        musicIcon.textContent = 'music_off';
        localStorage.setItem('musicState', 'paused');
    });
  } else {
    isMusicPlaying = false;
    musicIcon.textContent = 'music_off';
  }

})();
</script>
</body>
</html>
