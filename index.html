<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRUIT CRUSH - Match 3 Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Inter:wght@400;700&display=swap');
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  body {
    font-family: 'Fredoka One', cursive, 'Inter', sans-serif;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    color: #e0e6f1;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 16px;
    overflow-x: hidden;
    user-select: none;
  }
  h1 {
    font-weight: 700;
    font-size: 2.5rem;
    margin-bottom: 16px;
    background: linear-gradient(45deg, #8b5cf6, #06b6d4);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    user-select: none;
    text-shadow: 2px 2px 8px rgba(0,0,0,0.6);
  }
  .game-container {
    background: rgba(255 255 255 / 0.05);
    border-radius: 20px;
    padding: 24px;
    width: 100%;
    max-width: 480px;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    box-shadow: 0 8px 40px rgb(139 92 246 / 0.5);
    position: relative;
  }
  .status-bar {
    width: 100%;
    display: flex;
    justify-content: space-around;
    font-weight: 700;
    font-size: 1.1rem;
    margin-bottom: 24px;
    font-family: 'Fredoka One', cursive;
    gap: 14px;
    flex-wrap: wrap;
  }
  .status-item {
    background: rgba(255 255 255 / 0.15);
    border-radius: 14px;
    padding: 12px 18px;
    min-width: 110px;
    text-align: center;
    box-shadow: 0 5px 14px rgba(11, 16, 22, 0.35);
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #e0e6f1;
  }
  .status-label {
    font-size: 0.8rem;
    color: #bbbbcc;
    margin-bottom: 3px;
    user-select: none;
  }
  .status-value {
    font-size: 1.5rem;
    font-weight: 800;
    letter-spacing: 1.2px;
    user-select: none;
  }
  #grid {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    gap: 8px;
    margin-bottom: 24px;
    position: relative; /* For falling animation */
  }
  .cell {
    background: #2a3152;
    border-radius: 14px;
    box-shadow: inset 0 0 12px rgba(255, 255, 255 / 0.12);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    cursor: pointer;
    user-select: none;
    transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
    will-change: transform, opacity;
    position: relative;
    z-index: 1;
  }
  .cell[data-color="0"] { color: #ff4b5c; }
  .cell[data-color="1"] { color: #ffd662; }
  .cell[data-color="2"] { color: #4cd137; }
  .cell[data-color="3"] { color: #2980b9; }
  .cell[data-color="4"] { color: #9b59b6; }
  .cell[data-color="5"] { color: #e67e22; }
  .cell.selected {
    outline: 4px solid #8b5cf6;
    transform: scale(1.15);
    box-shadow: 0 0 18px #8b5cf6;
    z-index: 10;
  }
  /* Gaya untuk bonus */
  .cell.bonus-row {
    border: 3px solid #06b6d4;
    box-shadow: 0 0 15px #06b6d4;
  }
  .cell.bonus-column {
    border: 3px solid #8b5cf6;
    box-shadow: 0 0 15px #8b5cf6;
  }
  .cell.bonus-bomb {
    border: 3px solid #ff4b5c;
    box-shadow: 0 0 15px #ff4b5c;
    transform: rotate(5deg);
  }
  .cell.bonus-color-bomb {
    background: radial-gradient(circle, #f06, #a0c);
    box-shadow: 0 0 20px #f06, inset 0 0 10px #fff;
    border: 2px solid #fff;
    transform: rotate(15deg);
  }
  /* Animasi penghapusan */
  .cell.removing {
    animation: fadeOutScale 0.4s forwards;
  }
  @keyframes fadeOutScale {
    from { transform: scale(1); opacity: 1; }
    to { transform: scale(0); opacity: 0; }
  }

  /* Gaya untuk blokir */
  .cell.ice-block {
    background: linear-gradient(45deg, #a0d9e0, #c0eaf0);
    border: 2px solid #80c9d0;
    box-shadow: inset 0 0 10px rgba(255,255,255,0.5);
    color: #333;
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
  }
  .cell.ice-block[data-hits="1"] {
    background: linear-gradient(45deg, #c0eaf0, #e0faff);
    border: 2px solid #a0d9e0;
  }
  .cell.ice-block .item-content {
    display: none; /* Sembunyikan item di balik blokir */
  }

  /* Gaya untuk item khusus (collectible) */
  .cell.collectible {
    background: #f0f0f0; /* Warna latar belakang berbeda */
    border: 2px solid #ccc;
    box-shadow: inset 0 0 8px rgba(0,0,0,0.2);
    font-size: 2.5rem; /* Ukuran lebih besar */
    color: #555;
  }

  /* Animasi jatuh */
  .cell.falling {
    transition: transform 0.5s ease-out;
  }

  button {
    background: #8b5cf6;
    color: white;
    border: none;
    border-radius: 16px;
    padding: 14px 28px;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 22px rgba(139, 92, 246, 0.9);
    transition: background-color 0.3s ease;
    margin: 6px;
    min-width: 110px;
    font-family: 'Fredoka One', cursive;
    font-size: 1.15rem;
  }
  button:hover:not(:disabled) {
    background: #06b6d4;
    box-shadow: 0 0 32px #06b6d4;
  }
  button:disabled {
    background: #444c5c;
    cursor: not-allowed;
    box-shadow: none;
    color: #999;
  }
  .controls {
    width: 100%;
    display: flex;
    justify-content: space-around;
    gap: 16px;
    margin-bottom: 20px;
  }
  .power-ups {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
  }
  .power-up-btn {
    background: #e67e22;
    box-shadow: 0 0 15px rgba(230, 126, 34, 0.7);
    padding: 10px 15px;
    min-width: unset;
    font-size: 1rem;
  }
  .power-up-btn:hover:not(:disabled) {
    background: #d35400;
    box-shadow: 0 0 20px rgba(211, 84, 0, 0.9);
  }

  #message {
    font-weight: 700;
    font-size: 1.3rem;
    min-height: 36px;
    color: #00ff90;
    user-select: none;
    text-align: center;
    font-family: 'Fredoka One', cursive;
    padding: 0 16px;
    transition: opacity 0.5s ease;
  }
  .music-control, .sound-control { /* Added .sound-control */
    position: absolute;
    top: 16px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    transition: background-color 0.3s ease;
  }
  .music-control {
    right: 16px;
  }
  .sound-control { /* Position for sound control */
    right: 66px; /* Adjust as needed to place it next to music control */
  }
  .music-control:hover, .sound-control:hover { /* Added .sound-control */
    background: rgba(255, 255, 255, 0.2);
  }
  .music-control .material-icons, .sound-control .material-icons { /* Added .sound-control */
    color: #e0e6f1;
    font-size: 24px;
  }

  #collectTarget {
    width: 100%;
    margin-top: 10px;
    padding: 10px;
    background: rgba(255 255 255 / 0.1);
    border-radius: 10px;
    text-align: center;
    font-size: 0.9rem;
    color: #e0e6f1;
    display: none;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
  }
  .collect-item {
    display: flex;
    align-items: center;
    gap: 5px;
    background: rgba(255 255 255 / 0.15);
    padding: 5px 10px;
    border-radius: 8px;
  }
  .collect-item .icon {
    font-size: 1.5rem;
  }
  .collect-item .count {
    font-weight: bold;
  }

  /* Modal Styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
  }
  .modal-overlay.active {
    opacity: 1;
    visibility: visible;
  }
  .modal-content {
    background: linear-gradient(135deg, #203a43, #0f2027);
    padding: 30px;
    border-radius: 20px;
    text-align: center;
    box-shadow: 0 10px 50px rgba(0,0,0,0.8);
    transform: scale(0.8);
    transition: transform 0.3s ease;
  }
  .modal-overlay.active .modal-content {
    transform: scale(1);
  }
  .modal-content h2 {
    font-size: 2.5rem;
    margin-bottom: 20px;
    background: linear-gradient(45deg, #06b6d4, #8b5cf6);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .modal-content p {
    font-size: 1.2rem;
    margin-bottom: 30px;
    color: #e0e6f1;
  }
  .modal-content button {
    background: #8b5cf6;
    font-size: 1.2rem;
    padding: 12px 25px;
    border-radius: 12px;
  }
  .modal-content button:hover {
    background: #06b6d4;
  }

  @media (max-width: 480px) {
    h1 {
      font-size: 1.8rem;
      margin-bottom: 10px;
    }
    .status-bar {
      font-size: 0.95rem;
      gap: 10px;
      flex-wrap: wrap;
    }
    .status-item {
      min-width: 80px;
      padding: 8px 12px;
    }
    .status-label {
      font-size: 0.65rem;
    }
    .status-value {
      font-size: 1.1rem;
    }
    #grid {
      gap: 6px;
    }
    .cell {
      font-size: 24px;
      border-radius: 12px;
    }
    button {
      min-width: 90px;
      padding: 12px 20px;
      font-size: 1rem;
    }
    #message {
      font-size: 1.1rem;
      min-height: 32px;
    }
    .music-control, .sound-control { /* Added .sound-control */
      top: 10px;
      width: 35px;
      height: 35px;
    }
    .music-control {
      right: 10px;
    }
    .sound-control { /* Position for sound control */
      right: 55px; /* Adjust for smaller screens */
    }
    .music-control .material-icons, .sound-control .material-icons { /* Added .sound-control */
      font-size: 20px;
    }
    .modal-content {
      padding: 20px;
    }
    .modal-content h2 {
      font-size: 2rem;
    }
    .modal-content p {
      font-size: 1rem;
    }
  }
</style>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
</head>
<body>
<h1>FRUIT CRUSH</h1>
<div class="game-container" role="main" aria-label="game grid area">
  <div class="status-bar" aria-live="polite" aria-atomic="true">
    <div class="status-item" id="levelIndicator">
      <div class="status-label">LEVEL</div>
      <div class="status-value">1</div>
    </div>
    <div class="status-item" id="targetScoreIndicator">
      <div class="status-label">TARGET SKOR</div>
      <div class="status-value">500</div>
    </div>
    <div class="status-item" id="scoreIndicator">
      <div class="status-label">SKOR</div>
      <div class="status-value">0</div>
    </div>
    <div class="status-item" id="timeIndicator">
      <div class="status-label">GERAKAN</div>
      <div class="status-value">25 moves</div>
    </div>
  </div>
  <div id="collectTarget" style="display: none;">
    <!-- Target pengumpulan item akan dirender di sini -->
  </div>
  <div id="grid" aria-label="Game board" tabindex="0"></div>
  <div class="power-ups">
    <button id="shuffleBtn" class="power-up-btn" aria-label="Acak Papan" title="Acak Papan">
      <span class="material-icons">shuffle</span> Acak (<span id="shuffleCount">1</span>)
    </button>
    <button id="hammerBtn" class="power-up-btn" aria-label="Hancurkan Item" title="Hancurkan Item">
      <span class="material-icons">gavel</span> Palu (<span id="hammerCount">1</span>)
    </button>
  </div>
  <div class="controls">
    <button id="startBtn" aria-label="Mulai Permainan" title="Mulai Permainan">
      <span class="material-icons" aria-hidden="true">play_arrow</span> Mulai
    </button>
    <button id="pauseBtn" aria-label="Jeda Permainan" title="Jeda Permainan" disabled>
      <span class="material-icons" aria-hidden="true">pause</span> Jeda
    </button>
    <button id="retryBtn" aria-label="Ulang Level" title="Ulang Level" disabled>
      <span class="material-icons" aria-hidden="true">replay</span> Ulang
    </button>
  </div>
  <div id="message" role="alert" aria-live="assertive"></div>
</div>

<!-- Modal untuk Game Over / Level Complete -->
<div id="gameModal" class="modal-overlay">
  <div class="modal-content">
    <h2 id="modalTitle"></h2>
    <p id="modalMessage"></p>
    <button id="modalActionBtn"></button>
  </div>
</div>

<!-- Elemen Audio untuk Musik Latar -->
<audio id="backgroundMusic" loop>
  <source src="https://www.bensound.com/bensound-music/bensound-ukulele.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>

<!-- Elemen Audio untuk Efek Suara -->
<audio id="swapSound" src="https://www.soundjay.com/buttons/sounds/button-1.mp3"></audio>
<audio id="matchSound" src="https://www.soundjay.com/buttons/sounds/button-2.mp3"></audio>
<audio id="bonusSound" src="https://www.soundjay.com/buttons/sounds/button-3.mp3"></audio>
<audio id="gameOverSound" src="https://www.soundjay.com/misc/sounds/fail-buzzer-01.mp3"></audio>
<audio id="levelUpSound" src="https://www.soundjay.com/misc/sounds/success-fanfare-01.mp3"></audio>
<audio id="powerUpSound" src="https://www.soundjay.com/misc/sounds/power-up.mp3"></audio>
<audio id="blockHitSound" src="https://www.soundjay.com/misc/sounds/block-hit.mp3"></audio>


<!-- Tombol Kontrol Musik -->
<div class="music-control" id="musicControlBtn" aria-label="Kontrol Musik">
  <span class="material-icons" id="musicIcon">music_note"></span>
</div>

<!-- Tombol Kontrol Sound Effect -->
<div class="sound-control" id="soundControlBtn" aria-label="Kontrol Sound Effect">
  <span class="material-icons" id="soundIcon">volume_up</span>
</div>

<script>
(() => {
  'use strict';

  const ROWS = 8;
  const COLS = 8;
  const BASE_MOVES = 25;
  const MAX_LEVEL = 100;
  const COLOR_SETS = [3,4,4,4,5,5,5,6,6,6];
  const ITEM_SHAPES = ['🍒', '🍋', '🥝', '🍇', '🍓', '🍊'];
  const COLLECTIBLE_SHAPES = ['⭐', '💎', '👑']; // Item khusus yang harus dikumpulkan

  const BONUS_TYPES = {
    NONE: 'none',
    ROW: 'bonus-row',
    COLUMN: 'bonus-column',
    BOMB: 'bonus-bomb',
    COLOR_BOMB: 'bonus-color-bomb'
  };

  const CELL_TYPES = {
    NORMAL: 'normal',
    ICE: 'ice-block',
    COLLECTIBLE: 'collectible'
  };

  const gridElement = document.getElementById('grid');
  const levelIndicator = document.getElementById('levelIndicator');
  const scoreIndicator = document.getElementById('scoreIndicator');
  const targetScoreIndicator = document.getElementById('targetScoreIndicator');
  const movesIndicator = document.getElementById('timeIndicator');
  const messageElement = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const retryBtn = document.getElementById('retryBtn');
  const collectTargetElement = document.getElementById('collectTarget');

  // Power-up buttons
  const shuffleBtn = document.getElementById('shuffleBtn');
  const hammerBtn = document.getElementById('hammerBtn');
  const shuffleCountSpan = document.getElementById('shuffleCount');
  const hammerCountSpan = document.getElementById('hammerCount');

  // Modal elements
  const gameModal = document.getElementById('gameModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalMessage = document.getElementById('modalMessage');
  const modalActionBtn = document.getElementById('modalActionBtn');

  // Audio elements
  const backgroundMusic = document.getElementById('backgroundMusic');
  const musicControlBtn = document.getElementById('musicControlBtn');
  const musicIcon = document.getElementById('musicIcon');

  // Sound Effect elements
  const swapSound = document.getElementById('swapSound');
  const matchSound = document.getElementById('matchSound');
  const bonusSound = document.getElementById('bonusSound');
  const gameOverSound = document.getElementById('gameOverSound');
  const levelUpSound = document.getElementById('levelUpSound');
  const powerUpSound = document.getElementById('powerUpSound');
  const blockHitSound = document.getElementById('blockHitSound');
  const soundControlBtn = document.getElementById('soundControlBtn'); // New
  const soundIcon = document.getElementById('soundIcon');             // New

  let level = 1;
  let score = 0;
  let moves = BASE_MOVES;
  let maxMoves = BASE_MOVES;
  let isPaused = false;
  let selectedCell = null;
  let isAnimating = false; // Controls user interaction during animations
  let detailedGrid = [];
  let isMusicPlaying = false;
  let isSoundEffectOn = true; // New: Default sound effects are ON

  let targetCollect = {}; // {color: amount} for normal items, {type: amount} for collectibles
  let currentCollected = {}; // {color: amount} for normal items, {type: amount} for collectibles

  let shufflePowerUps = 1;
  let hammerPowerUps = 1;
  let activePowerUp = null; // 'hammer' or null

  const delay = ms => new Promise(res => setTimeout(res, ms));
  const idx = (r,c) => r * COLS + c;

  function getRandomInt(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Modified playSound to respect isSoundEffectOn
  function playSound(audioElement) {
    if (audioElement && isSoundEffectOn) { // Check isSoundEffectOn
      audioElement.currentTime = 0;
      audioElement.play().catch(e => console.warn("Audio play failed:", e));
    }
  }

  function initGrid(){
    const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
    detailedGrid = [];
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        let cell = {
          type: CELL_TYPES.NORMAL,
          color: getRandomInt(0, colorCount - 1),
          bonus: BONUS_TYPES.NONE,
          hits: 0 // For ice blocks
        };

        // Add ice blocks randomly for demonstration
        if (level >= 2 && Math.random() < 0.15) { // 15% chance for ice block from level 2
            cell.type = CELL_TYPES.ICE;
            cell.hits = getRandomInt(1, 2); // 1 or 2 hits to break
            cell.color = -1; // Ice blocks don't have a color
        }
        // Add collectible items randomly for demonstration
        if (level >= 3 && Math.random() < 0.05 && cell.type === CELL_TYPES.NORMAL) { // 5% chance for collectible from level 3
            cell.type = CELL_TYPES.COLLECTIBLE;
            cell.collectibleType = getRandomInt(0, COLLECTIBLE_SHAPES.length - 1);
            cell.color = -1; // Collectibles don't have a color for matching
        }

        detailedGrid[idx(r,c)] = cell;
      }
    }
    removeInitialMatches();
  }

  function removeInitialMatches(){
    const matches = findMatches();
    if(matches.length > 0){
      matches.forEach(i => {
        if (detailedGrid[i].type === CELL_TYPES.NORMAL) {
            detailedGrid[i].color = getRandomInt(0, (level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6) - 1);
        }
      });
      removeInitialMatches();
    }
  }

  function renderGrid(){
    gridElement.innerHTML = '';
    gridElement.style.pointerEvents = isAnimating ? 'none' : 'auto';
    for(let i=0; i<detailedGrid.length; i++){
      const cellData = detailedGrid[i];
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;

      if (cellData.type === CELL_TYPES.NORMAL) {
          cell.dataset.color = cellData.color;
          cell.textContent = ITEM_SHAPES[cellData.color];
          if(cellData.bonus && cellData.bonus !== BONUS_TYPES.NONE) {
            cell.classList.add(cellData.bonus);
          }
          cell.setAttribute('aria-label', `Item warna nomor ${cellData.color + 1}${cellData.bonus !== BONUS_TYPES.NONE ? `, bonus ${cellData.bonus.replace('bonus-', '')}` : ""}`);
      } else if (cellData.type === CELL_TYPES.ICE) {
          cell.classList.add('ice-block');
          cell.dataset.hits = cellData.hits;
          cell.textContent = cellData.hits > 0 ? `❄️${cellData.hits}` : ''; // Show hits remaining
          cell.setAttribute('aria-label', `Blok es, ${cellData.hits} pukulan tersisa`);
      } else if (cellData.type === CELL_TYPES.COLLECTIBLE) {
          cell.classList.add('collectible');
          cell.textContent = COLLECTIBLE_SHAPES[cellData.collectibleType];
          cell.setAttribute('aria-label', `Item koleksi ${COLLECTIBLE_SHAPES[cellData.collectibleType]}`);
      }

      if(selectedCell === i) cell.classList.add('selected');
      cell.setAttribute('tabindex','0');
      cell.setAttribute('role','button');
      cell.onclick = () => onCellClicked(i);
      gridElement.appendChild(cell);
    }
    updatePowerUpButtons();
  }

  function isAdjacent(a, b){
    const r1 = Math.floor(a/COLS), c1 = a%COLS;
    const r2 = Math.floor(b/COLS), c2 = b%COLS;
    return (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
  }

  async function onCellClicked(index){
    if(isAnimating || isPaused) return;

    if (activePowerUp === 'hammer') {
        await useHammer(index);
        activePowerUp = null;
        renderGrid(); // Re-render to remove hammer selection
        return;
    }

    if(selectedCell === null){
      selectedCell = index;
    } else {
      if(selectedCell === index){
        selectedCell = null;
      } else if(isAdjacent(selectedCell, index)){
        // Prevent swapping with ice blocks or collectibles directly
        if (detailedGrid[selectedCell].type !== CELL_TYPES.NORMAL || detailedGrid[index].type !== CELL_TYPES.NORMAL) {
            selectedCell = index; // Select new cell if invalid swap
            renderGrid();
            return;
        }

        await swapAndCheck(selectedCell, index);
        selectedCell = null;
      } else {
        selectedCell = index;
      }
    }
    renderGrid();
  }

  // Helper to deep copy a cell object
  function copyCell(cell) {
      return { ...cell };
  }

  // Helper to deep copy the entire grid
  function copyGrid(grid) {
      return grid.map(cell => copyCell(cell));
  }

  // This function now operates on a provided grid (tempGrid or detailedGrid)
  function findMatches(gridToSearch = detailedGrid){
    const matchesSet = new Set();
    const bonusCandidates = [];

    // Check horizontal
    for(let r = 0; r < ROWS; r++){
      let chainStart = 0;
      for(let c = 1; c <= COLS; c++){
        if(c < COLS && gridToSearch[idx(r,c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r,chainStart)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r,c)].color === gridToSearch[idx(r,chainStart)].color) continue;
        const length = c - chainStart;
        if(length >= 3){
          for(let k = chainStart; k < c; k++) {
            if (gridToSearch[idx(r,k)].type === CELL_TYPES.NORMAL) {
                matchesSet.add(idx(r,k));
            }
          }
          if(length === 4){
            const bonusPos = idx(r, Math.floor((chainStart + c - 1) / 2));
            if (gridToSearch[bonusPos].type === CELL_TYPES.NORMAL) bonusCandidates.push({pos: bonusPos, type: 'row_bonus'});
          } else if (length >= 5) {
            const bonusPos = idx(r, Math.floor((chainStart + c - 1) / 2));
            if (gridToSearch[bonusPos].type === CELL_TYPES.NORMAL) bonusCandidates.push({pos: bonusPos, type: 'color_bomb'});
          }
        }
        chainStart = c;
      }
    }

    // Check vertical
    for(let c = 0; c < COLS; c++){
      let chainStart = 0;
      for(let r = 1; r <= ROWS; r++){
        if(r < ROWS && gridToSearch[idx(r,c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(chainStart,c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r,c)].color === gridToSearch[idx(chainStart,c)].color) continue;
        const length = r - chainStart;
        if(length >= 3){
          for(let k = chainStart; k < r; k++) {
            if (gridToSearch[idx(k,c)].type === CELL_TYPES.NORMAL) {
                matchesSet.add(idx(k,c));
            }
          }
          if(length === 4){
            const bonusPos = idx(Math.floor((chainStart + r - 1) / 2), c);
            if (gridToSearch[bonusPos].type === CELL_TYPES.NORMAL) bonusCandidates.push({pos: bonusPos, type: 'column_bonus'});
          } else if (length >= 5) {
            const bonusPos = idx(Math.floor((chainStart + r - 1) / 2), c);
            if (gridToSearch[bonusPos].type === CELL_TYPES.NORMAL) bonusCandidates.push({pos: bonusPos, type: 'color_bomb'});
          }
        }
        chainStart = r;
      }
    }

    // Check T/L shapes (simplified for this example)
    // This part needs to be adapted to use gridToSearch as well
    // For a full implementation, checkTLMatch would also need to accept gridToSearch
    // For now, we'll assume findMatches is primarily for detailedGrid or a copy of it.
    // If you need to check T/L on tempGrid, you'd pass tempGrid to checkTLMatch.
    // For simplicity in this hasPossibleMoves context, we might skip complex bonus creation checks.

    return Array.from(matchesSet);
  }

  async function swapAndCheck(a,b){
    isAnimating = true; // Disable interaction during this sequence

    const cellA = detailedGrid[a];
    const cellB = detailedGrid[b];

    let specialInteractionOccurred = false;
    let bonusCombination = BONUS_TYPES.NONE;

    // --- Handle Special Interactions (Color Bomb + Normal, Bonus + Bonus) ---
    // Color Bomb + Normal Item
    if (cellA.bonus === BONUS_TYPES.COLOR_BOMB && cellB.type === CELL_TYPES.NORMAL && cellB.bonus === BONUS_TYPES.NONE) {
      specialInteractionOccurred = true;
      // Perform visual swap immediately
      [detailedGrid[a], detailedGrid[b]] = [detailedGrid[b], detailedGrid[a]];
      renderGrid();
      playSound(swapSound);
      await delay(300);
      await processSpecialMatches([a, b], cellB.color);
    } else if (cellB.bonus === BONUS_TYPES.COLOR_BOMB && cellA.type === CELL_TYPES.NORMAL && cellA.bonus === BONUS_TYPES.NONE) {
      specialInteractionOccurred = true;
      // Perform visual swap immediately
      [detailedGrid[a], detailedGrid[b]] = [detailedGrid[b], detailedGrid[a]];
      renderGrid();
      playSound(swapSound);
      await delay(300);
      await processSpecialMatches([a, b], cellA.color);
    }
    // Bonus Combinations
    else if (cellA.bonus !== BONUS_TYPES.NONE && cellB.bonus !== BONUS_TYPES.NONE) {
        specialInteractionOccurred = true;
        // Determine combination type
        if ((cellA.bonus === BONUS_TYPES.COLOR_BOMB && (cellB.bonus === BONUS_TYPES.ROW || cellB.bonus === BONUS_TYPES.COLUMN)) ||
            (cellB.bonus === BONUS_TYPES.COLOR_BOMB && (cellA.bonus === BONUS_TYPES.ROW || cellA.bonus === BONUS_TYPES.COLUMN))) {
            bonusCombination = 'color_striped';
        } else if ((cellA.bonus === BONUS_TYPES.COLOR_BOMB && cellB.bonus === BONUS_TYPES.BOMB) ||
                   (cellB.bonus === BONUS_TYPES.COLOR_BOMB && cellA.bonus === BONUS_TYPES.BOMB)) {
            bonusCombination = 'color_wrapped';
        } else if ((cellA.bonus === BONUS_TYPES.ROW || cellA.bonus === BONUS_TYPES.COLUMN) &&
                   (cellB.bonus === BONUS_TYPES.ROW || cellB.bonus === BONUS_TYPES.COLUMN)) {
            bonusCombination = 'striped_striped';
        } else if ((cellA.bonus === BONUS_TYPES.BOMB && cellB.bonus === BONUS_TYPES.BOMB)) {
            bonusCombination = 'wrapped_wrapped';
        } else if (((cellA.bonus === BONUS_TYPES.ROW || cellA.bonus === BONUS_TYPES.COLUMN) && cellB.bonus === BONUS_TYPES.BOMB) ||
                   ((cellB.bonus === BONUS_TYPES.ROW || cellB.bonus === BONUS_TYPES.COLUMN) && cellA.bonus === BONUS_TYPES.BOMB)) {
            bonusCombination = 'striped_wrapped';
        } else if (cellA.bonus === BONUS_TYPES.COLOR_BOMB && cellB.bonus === BONUS_TYPES.COLOR_BOMB) {
            bonusCombination = 'color_color';
        }
        // Perform visual swap immediately
        [detailedGrid[a], detailedGrid[b]] = [detailedGrid[b], detailedGrid[a]];
        renderGrid();
        playSound(swapSound);
        await delay(300);
        await processBonusCombination(a, b, bonusCombination);
    }

    // --- Handle Regular Swaps (check for match before visual swap) ---
    if (!specialInteractionOccurred) {
        const tempGrid = copyGrid(detailedGrid); // Create a temporary copy of the grid
        // Simulate the swap on the temporary grid
        [tempGrid[a], tempGrid[b]] = [tempGrid[b], tempGrid[a]];

        const matches = findMatches(tempGrid); // Check for matches on the simulated grid

        if(matches.length > 0){
            // If matches found, perform the actual swap on detailedGrid
            [detailedGrid[a], detailedGrid[b]] = [detailedGrid[b], detailedGrid[a]];
            renderGrid(); // Update visual grid
            playSound(swapSound);
            await delay(300); // Short delay for visual swap animation

            await processMatches(matches); // Process the matches
        } else {
            // No match found, do not perform visual swap, just re-enable interaction
            isAnimating = false;
            return; // Exit function, no move was made
        }
    }

    // Only decrement moves if a match or special interaction occurred
    // This block is now outside the `if (!specialInteractionOccurred)` to ensure it runs for all valid moves
    moves--;
    movesIndicator.querySelector('.status-value').textContent = `${moves} moves`;
    if (moves <= 0) {
        gameOver();
    } else {
        // After every valid move sequence, check for possible moves
        if (!hasPossibleMoves()) {
            showMessage("Tidak ada gerakan yang mungkin! Game Over.", true);
            gameOver();
        }
    }
  }

  // This function now operates on a provided grid (tempGrid or detailedGrid)
  function checkTLMatch(r, c, color, matchesSet, gridToSearch = detailedGrid) {
      // T-shapes
      // Horizontal T: X X X (middle X is (r,c))
      //                 X
      if (c > 0 && c < COLS - 1 && r < ROWS - 1 &&
          gridToSearch[idx(r, c - 1)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r, c - 1)].color === color &&
          gridToSearch[idx(r, c + 1)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r, c + 1)].color === color &&
          gridToSearch[idx(r + 1, c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r + 1, c)].color === color) {
          if (matchesSet.has(idx(r, c - 1)) && matchesSet.has(idx(r, c)) && matchesSet.has(idx(r, c + 1)) && matchesSet.has(idx(r + 1, c))) {
              return { pos: idx(r, c), type: 'bomb_bonus' };
          }
      }
      // Vertical T: X
      //             X X (middle X is (r,c))
      //             X
      if (r > 0 && r < ROWS - 1 && c < COLS - 1 &&
          gridToSearch[idx(r - 1, c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r - 1, c)].color === color &&
          gridToSearch[idx(r + 1, c)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r + 1, c)].color === color &&
          gridToSearch[idx(r, c + 1)].type === CELL_TYPES.NORMAL && gridToSearch[idx(r, c + 1)].color === color) {
          if (matchesSet.has(idx(r - 1, c)) && matchesSet.has(idx(r, c)) && matchesSet.has(idx(r + 1, c)) && matchesSet.has(idx(r, c + 1))) {
              return { pos: idx(r, c), type: 'bomb_bonus' };
          }
      }
      // Add other T and L orientations as needed for full coverage
      return null;
  }

  async function processMatches(matchedIndices){
    if(matchedIndices.length === 0){
        isAnimating = false; // Re-enable interaction if no matches to process
        return;
    }

    playSound(matchSound);

    const cellsToClear = new Set(); // All cells that will be removed
    const cellsToHit = new Set(); // Cells that will take damage (e.g., ice blocks)

    matchedIndices.forEach(i => {
        const cell = detailedGrid[i];
        if (cell.type === CELL_TYPES.NORMAL) {
            cellsToClear.add(i);
            // Expand based on bonus
            if(cell.bonus === BONUS_TYPES.ROW){
                playSound(bonusSound);
                const r = Math.floor(i / COLS);
                for(let c=0; c<COLS; c++) cellsToClear.add(idx(r,c));
            } else if(cell.bonus === BONUS_TYPES.COLUMN){
                playSound(bonusSound);
                const c = i % COLS;
                for(let r=0; r<ROWS; r++) cellsToClear.add(idx(r,c));
            } else if(cell.bonus === BONUS_TYPES.BOMB){
                playSound(bonusSound);
                const r = Math.floor(i / COLS);
                const c = i % COLS;
                for(let dr=-1; dr<=1; dr++){
                    for(let dc=-1; dc<=1; dc++){
                        const nr = r + dr, nc = c + dc;
                        if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) cellsToClear.add(idx(nr,nc));
                    }
                }
            } else if(cell.bonus === BONUS_TYPES.COLOR_BOMB){
                playSound(bonusSound);
                for (let j = 0; j < detailedGrid.length; j++) {
                    cellsToClear.add(j);
                }
            }
        } else if (cell.type === CELL_TYPES.ICE) {
            cellsToHit.add(i); // Ice blocks are hit, not cleared directly by match
        }
    });

    // Process hits on ice blocks
    cellsToClear.forEach(i => {
        const r = Math.floor(i / COLS);
        const c = i % COLS;
        // Check neighbors for ice blocks
        const neighbors = [
            idx(r-1, c), idx(r+1, c), idx(r, c-1), idx(r, c+1), // Direct neighbors
            idx(r-1, c-1), idx(r-1, c+1), idx(r+1, c-1), idx(r+1, c+1) // Diagonal neighbors (for bomb effect)
        ];
        neighbors.forEach(nIdx => {
            if (nIdx >= 0 && nIdx < detailedGrid.length && detailedGrid[nIdx].type === CELL_TYPES.ICE) {
                cellsToHit.add(nIdx);
            }
        });
    });

    // Apply damage to ice blocks
    cellsToHit.forEach(i => {
        if (detailedGrid[i].type === CELL_TYPES.ICE) {
            detailedGrid[i].hits--;
            playSound(blockHitSound);
            if (detailedGrid[i].hits <= 0) {
                cellsToClear.add(i); // Add to clear list if destroyed
            }
        }
    });

    score += cellsToClear.size * 10;
    scoreIndicator.querySelector('.status-value').textContent = score;

    // Collect items and animate removal
    cellsToClear.forEach(i => {
        const cell = detailedGrid[i];
        if (cell.type === CELL_TYPES.NORMAL) {
            currentCollected[cell.color] = (currentCollected[cell.color] || 0) + 1;
        } else if (cell.type === CELL_TYPES.COLLECTIBLE) {
            currentCollected[cell.collectibleType] = (currentCollected[cell.collectibleType] || 0) + 1;
        }
        const domCell = gridElement.children[i];
        if(domCell){
            domCell.classList.add('removing');
        }
    });
    updateCollectTargetUI();

    await delay(400);

    // Set cleared cells to empty
    cellsToClear.forEach(i => {
      detailedGrid[i] = { type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0 };
    });

    await dropCandies(); // This now handles animation
    refillGrid();
    renderGrid();

    await delay(300);

    const newMatches = findMatches();
    if(newMatches.length > 0){
      await processMatches(newMatches); // Recursive call for chain reactions
    } else{
      isAnimating = false; // Re-enable interaction only after all chain reactions are done
      checkLevelCompletion();
    }
  }

  async function processSpecialMatches(originIndices, colorToClear) {
      playSound(bonusSound);
      const cellsToClear = new Set(originIndices);

      for (let i = 0; i < detailedGrid.length; i++) {
          if (detailedGrid[i].type === CELL_TYPES.NORMAL && detailedGrid[i].color === colorToClear) {
              cellsToClear.add(i);
          }
      }

      // Process hits on ice blocks adjacent to cleared cells
      cellsToClear.forEach(i => {
          const r = Math.floor(i / COLS);
          const c = i % COLS;
          for(let dr=-1; dr<=1; dr++){
              for(let dc=-1; dc<=1; dc++){
                  const nr = r + dr, nc = c + dc;
                  const nIdx = idx(nr, nc);
                  if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && detailedGrid[nIdx].type === CELL_TYPES.ICE) {
                      detailedGrid[nIdx].hits--;
                      playSound(blockHitSound);
                      if (detailedGrid[nIdx].hits <= 0) {
                          cellsToClear.add(nIdx);
                      }
                  }
              }
          }
      });

      score += cellsToClear.size * 10;
      scoreIndicator.querySelector('.status-value').textContent = score;

      cellsToClear.forEach(i => {
          const cell = detailedGrid[i];
          if (cell.type === CELL_TYPES.NORMAL) {
              currentCollected[cell.color] = (currentCollected[cell.color] || 0) + 1;
          } else if (cell.type === CELL_TYPES.COLLECTIBLE) {
              currentCollected[cell.collectibleType] = (currentCollected[cell.collectibleType] || 0) + 1;
          }
          const domCell = gridElement.children[i];
          if(domCell){
              domCell.classList.add('removing');
          }
      });
      updateCollectTargetUI();

      await delay(400);

      cellsToClear.forEach(i => {
          detailedGrid[i] = { type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0 };
      });

      await dropCandies();
      refillGrid();
      renderGrid();

      await delay(300);

      const newMatches = findMatches();
      if(newMatches.length > 0){
          await processMatches(newMatches);
      } else{
          isAnimating = false;
          checkLevelCompletion();
      }
  }

  async function processBonusCombination(idx1, idx2, combinationType) {
      playSound(bonusSound);
      const cellsToClear = new Set();
      const cellsToHit = new Set();

      // Mark original bonus cells for removal
      cellsToClear.add(idx1);
      cellsToClear.add(idx2);

      if (combinationType === 'color_striped') {
          const targetColor = detailedGrid[idx1].color === -1 ? detailedGrid[idx2].color : detailedGrid[idx1].color;
          for (let i = 0; i < detailedGrid.length; i++) {
              if (detailedGrid[i].type === CELL_TYPES.NORMAL && detailedGrid[i].color === targetColor) {
                  // Activate striped effect for all items of that color
                  const r = Math.floor(i / COLS);
                  for(let c=0; c<COLS; c++) cellsToClear.add(idx(r,c));
                  const c = i % COLS;
                  for(let r=0; r<ROWS; r++) cellsToClear.add(idx(r,c));
              }
          }
      } else if (combinationType === 'color_wrapped') {
          const targetColor = detailedGrid[idx1].color === -1 ? detailedGrid[idx2].color : detailedGrid[idx1].color;
          for (let i = 0; i < detailedGrid.length; i++) {
              if (detailedGrid[i].color === targetColor) { // Check color regardless of type for this powerful combo
                  // Activate bomb effect for all items of that color
                  const r = Math.floor(i / COLS);
                  const c = i % COLS;
                  for(let dr=-1; dr<=1; dr++){
                    for(let dc=-1; dc<=1; dc++){
                      const nr = r + dr, nc = c + dc;
                      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) cellsToClear.add(idx(nr,nc));
                    }
                  }
              }
          }
      } else if (combinationType === 'striped_striped') {
          const r1 = Math.floor(idx1 / COLS), c1 = idx1 % COLS;
          const r2 = Math.floor(idx2 / COLS), c2 = idx2 % COLS;
          for(let c=0; c<COLS; c++) { cellsToClear.add(idx(r1,c)); cellsToClear.add(idx(r2,c)); }
          for(let r=0; r<ROWS; r++) { cellsToClear.add(idx(r,c1)); cellsToClear.add(idx(r,c2)); }
      } else if (combinationType === 'wrapped_wrapped') {
          const r = Math.floor(idx1 / COLS);
          const c = idx1 % COLS;
          for(let dr=-2; dr<=2; dr++){
              for(let dc=-2; dc<=2; dc++){
                  const nr = r + dr, nc = c + dc;
                  if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) cellsToClear.add(idx(nr,nc));
              }
          }
      } else if (combinationType === 'striped_wrapped') {
          const r = Math.floor(idx1 / COLS);
          const c = idx1 % COLS;
          for(let dr=-1; dr<=1; dr++){
              for(let dc=-1; dc<=1; dc++){
                  const nr = r + dr, nc = c + dc;
                  if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) cellsToClear.add(idx(nr,nc));
              }
          }
          for(let col=0; col<COLS; col++) cellsToClear.add(idx(r,col));
          for(let row=0; row<ROWS; row++) cellsToClear.add(idx(row,c));
      } else if (combinationType === 'color_color') {
          for (let i = 0; i < detailedGrid.length; i++) {
              cellsToClear.add(i);
          }
      }

      // Process hits on ice blocks adjacent to cleared cells
      cellsToClear.forEach(i => {
          const r = Math.floor(i / COLS);
          const c = i % COLS;
          for(let dr=-1; dr<=1; dr++){
              for(let dc=-1; dc<=1; dc++){
                  const nr = r + dr, nc = c + dc;
                  const nIdx = idx(nr, nc);
                  if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && detailedGrid[nIdx].type === CELL_TYPES.ICE) {
                      cellsToHit.add(nIdx);
                  }
              }
          }
      });

      cellsToHit.forEach(i => {
          detailedGrid[i].hits--;
          playSound(blockHitSound);
          if (detailedGrid[i].hits <= 0) {
              cellsToClear.add(i);
          }
      });

      score += cellsToClear.size * 10;
      scoreIndicator.querySelector('.status-value').textContent = score;

      cellsToClear.forEach(i => {
          const cell = detailedGrid[i];
          if (cell.type === CELL_TYPES.NORMAL) {
              currentCollected[cell.color] = (currentCollected[cell.color] || 0) + 1;
          } else if (cell.type === CELL_TYPES.COLLECTIBLE) {
              currentCollected[cell.collectibleType] = (currentCollected[cell.collectibleType] || 0) + 1;
          }
          const domCell = gridElement.children[i];
          if(domCell){
              domCell.classList.add('removing');
          }
      });
      updateCollectTargetUI();

      await delay(400);

      cellsToClear.forEach(i => {
          detailedGrid[i] = { type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0 };
      });

      await dropCandies();
      refillGrid();
      renderGrid();

      await delay(300);

      const newMatches = findMatches();
      if(newMatches.length > 0){
          await processMatches(newMatches);
      } else{
          isAnimating = false;
          checkLevelCompletion();
      }
  }

  async function dropCandies(){
    const cellsToAnimate = [];
    // Store initial positions for animation calculation
    const initialPositions = new Map();
    for (let i = 0; i < detailedGrid.length; i++) {
        initialPositions.set(detailedGrid[i], i);
    }

    for(let c=0; c<COLS; c++){
      let col = [];
      for(let r=ROWS-1; r>=0; r--){
        const cell = detailedGrid[idx(r,c)];
        if(cell.color !== -1 || cell.type === CELL_TYPES.ICE || cell.type === CELL_TYPES.COLLECTIBLE) {
            col.push(cell);
        }
      }
      // Fill top with empty cells
      while(col.length < ROWS) col.push({type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0});
      col.reverse(); // Items that fall are now at the bottom of the temp column

      for(let r=0; r<ROWS; r++){
        const currentCellInGrid = detailedGrid[idx(r,c)];
        const newCellForThisSpot = col[r];

        // If the cell at this position is changing, it means something fell or it's a new item
        if (currentCellInGrid !== newCellForThisSpot) { // Check if it's a different object reference
            const oldIndex = initialPositions.get(newCellForThisSpot); // Find where this new cell came from
            if (oldIndex !== undefined && oldIndex !== idx(r,c)) { // If it came from somewhere else
                cellsToAnimate.push({
                    element: gridElement.children[oldIndex], // Animate the actual DOM element that moved
                    fromRow: Math.floor(oldIndex / COLS),
                    toRow: r
                });
            }
        }
        detailedGrid[idx(r,c)] = newCellForThisSpot; // Update the detailedGrid
      }
    }

    // Apply falling animation
    if (cellsToAnimate.length > 0) {
        isAnimating = true; // Disable interaction during fall animation
        cellsToAnimate.forEach(({ element, fromRow, toRow }) => {
            const distance = (toRow - fromRow) * (element.offsetHeight + 8); // 8px is gap
            element.style.transition = 'none'; // Disable transition for initial position
            element.style.transform = `translateY(-${distance}px)`;
            // Force reflow
            void element.offsetWidth;
            element.style.transition = 'transform 0.5s ease-out';
            element.style.transform = 'translateY(0)';
        });
        await delay(500); // Wait for animation
        isAnimating = false; // Re-enable interaction after fall animation
    }

    // Check for collected items at the bottom row
    for (let c = 0; c < COLS; c++) {
        const bottomCellIdx = idx(ROWS - 1, c);
        const bottomCell = detailedGrid[bottomCellIdx];
        if (bottomCell.type === CELL_TYPES.COLLECTIBLE) {
            currentCollected[bottomCell.collectibleType] = (currentCollected[bottomCell.collectibleType] || 0) + 1;
            detailedGrid[bottomCellIdx] = { type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0 }; // Remove collectible
            playSound(bonusSound); // Play a sound for collecting
        }
    }
    updateCollectTargetUI();
  }

  function refillGrid(){
    const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
    for(let i=0; i<detailedGrid.length; i++){
      if(detailedGrid[i].color === -1 && detailedGrid[i].type === CELL_TYPES.NORMAL){
        detailedGrid[i].color = getRandomInt(0, colorCount - 1);
        detailedGrid[i].bonus = BONUS_TYPES.NONE;
      }
    }
    removeInitialMatches(); // Ensure no new matches are formed immediately after refill
  }

  function gameOver(){
    isAnimating = true;
    playSound(gameOverSound);
    showModal("Game Over!", `Level ${level} gagal. Skor Anda: ${score}.`, "Coba Lagi");
    pauseBtn.disabled = true;
    retryBtn.disabled = false;
    startBtn.disabled = false;
    isPaused = true;
    if (isMusicPlaying) {
        backgroundMusic.pause();
    }
  }

  function pauseGame(){
    if(isAnimating) return;
    isPaused = !isPaused;
    if(isPaused){
      pauseBtn.innerHTML = '<span class="material-icons" aria-hidden="true">play_arrow</span> Lanjutkan';
      showMessage("Permainan dijeda.", false);
      if (isMusicPlaying) {
          backgroundMusic.pause();
      }
    } else {
      pauseBtn.innerHTML = '<span class="material-icons" aria-hidden="true">pause</span> Jeda';
      showMessage("Permainan dilanjutkan.", false);
      if (isMusicPlaying) {
          backgroundMusic.play();
      }
    }
  }

  function checkLevelCompletion(){
    const currentTargetScore = level * 500;
    targetScoreIndicator.querySelector('.status-value').textContent = currentTargetScore;

    let scoreMet = score >= currentTargetScore;
    let collectTargetMet = true;

    for (const key in targetCollect) {
        if (targetCollect.hasOwnProperty(key)) {
            if ((currentCollected[key] || 0) < targetCollect[key]) {
                collectTargetMet = false;
                break;
            }
        }
    }

    if(scoreMet && collectTargetMet){
      prepareNextLevel();
    } else if (moves <= 0) {
        gameOver();
    } else if (!scoreMet) {
        showMessage(`Skor kurang! Butuh ${currentTargetScore - score} lagi.`, false);
    } else if (!collectTargetMet) {
        let missingItems = [];
        for (const key in targetCollect) {
            if (targetCollect.hasOwnProperty(key)) {
                const required = targetCollect[key];
                const collected = currentCollected[key] || 0;
                if (collected < required) {
                    // Check if it's a normal item color or a collectible type
                    const itemDisplay = ITEM_SHAPES[key] || COLLECTIBLE_SHAPES[key];
                    missingItems.push(`${required - collected} ${itemDisplay}`);
                }
            }
        }
        showMessage(`Kumpulkan ${missingItems.join(', ')} lagi!`, false);
    }

    // Only check for no possible moves if game is not animating and not already over
    if (!isAnimating && moves > 0 && !gameModal.classList.contains('active') && !hasPossibleMoves()) {
        showMessage("Tidak ada gerakan yang mungkin! Game Over.", true);
        gameOver();
    }
  }

  function prepareNextLevel(){
    playSound(levelUpSound);
    isAnimating = true;
    maxMoves = BASE_MOVES + (level * 3);
    if(level % 5 === 0){
      maxMoves += 10;
    }
    showModal("Level Selesai!", `Selamat! Anda menyelesaikan Level ${level}. Skor Anda: ${score}.`, "Lanjut Level");
    pauseBtn.disabled = true;
    retryBtn.disabled = true;
    startBtn.disabled = false;
    if (isMusicPlaying) {
        backgroundMusic.pause();
    }
  }

  function startNextLevel(){
    if(level < MAX_LEVEL){
      level++;
      score = 0;
      moves = maxMoves;
      selectedCell = null;
      isAnimating = false;
      targetCollect = {};
      currentCollected = {};

      // Give power-ups every few levels
      if (level % 5 === 0) shufflePowerUps++;
      if (level % 7 === 0) hammerPowerUps++;

      initGrid();
      renderGrid();
      updateButtons(true);
      updateUIElements();

      localStorage.setItem('fruitCrushMaxLevel', level);

      const targetScore = level * 500;
      targetScoreIndicator.querySelector('.status-value').textContent = targetScore;

      // Define new collection targets for this level
      if (level % 2 === 0) { // Every 2 levels, target a normal item
          const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
          const targetColor = getRandomInt(0, colorCount - 1);
          const targetAmount = 10 + Math.floor(level / 2) * 5;
          targetCollect[targetColor] = targetAmount;
          showMessage(`Level ${level} mulai! Kumpulkan ${targetAmount} ${ITEM_SHAPES[targetColor]}! Target skor: ${targetScore}`, false);
      } else if (level % 3 === 0) { // Every 3 levels, target a collectible
          const targetCollectibleType = getRandomInt(0, COLLECTIBLE_SHAPES.length - 1);
          const targetAmount = 3 + Math.floor(level / 3) * 1;
          targetCollect[targetCollectibleType] = targetAmount; // Use collectible type as key
          showMessage(`Level ${level} mulai! Kumpulkan ${targetAmount} ${COLLECTIBLE_SHAPES[targetCollectibleType]}! Target skor: ${targetScore}`, false);
      } else {
          showMessage(`Level ${level} mulai! Selamat bermain! Target skor: ${targetScore}`, false);
      }
      updateCollectTargetUI();

      if (isMusicPlaying) {
          backgroundMusic.play();
      }
    } else {
      showModal("Selamat!", `Anda menyelesaikan semua ${MAX_LEVEL} level! Skor akhir: ${score}`, "Mulai Ulang");
      pauseBtn.disabled = true;
      retryBtn.disabled = false;
      startBtn.disabled = false;
      if (isMusicPlaying) {
          backgroundMusic.pause();
      }
    }
  }

  function updateUIElements(){
    levelIndicator.querySelector('.status-value').textContent = level;
    scoreIndicator.querySelector('.status-value').textContent = score;
    movesIndicator.querySelector('.status-value').textContent = `${moves} moves`;
  }

  function updateButtons(gameStarted){
    startBtn.disabled = gameStarted;
    pauseBtn.disabled = !gameStarted;
    retryBtn.disabled = !gameStarted;
  }

  function showMessage(msg, isError = false){
    messageElement.textContent = msg;
    messageElement.style.color = isError ? '#ff5555' : '#00ff90';
  }

  function startGame(){
    if(gameModal.classList.contains('active')) { // If modal is open, close it first
        gameModal.classList.remove('active');
    }
    if(isAnimating && pauseBtn.disabled && retryBtn.disabled && !startBtn.disabled){
      startNextLevel();
      return;
    }
    level = 1;
    score = 0;
    maxMoves = BASE_MOVES;
    moves = maxMoves;
    isPaused = false;
    selectedCell = null;
    isAnimating = false;
    targetCollect = {};
    currentCollected = {};
    shufflePowerUps = 1; // Reset power-ups
    hammerPowerUps = 1;

    initGrid();
    renderGrid();
    updateButtons(true);
    updateUIElements();
    targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
    showMessage("Game dimulai! Selamat bermain!");
    updateCollectTargetUI();
    if (isMusicPlaying) {
        backgroundMusic.play();
    }
  }

  function retryLevel(){
    if(gameModal.classList.contains('active')) { // If modal is open, close it first
        gameModal.classList.remove('active');
    }
    score = 0;
    moves = maxMoves;
    selectedCell = null;
    isPaused = false;
    isAnimating = false;
    targetCollect = {};
    currentCollected = {};
    shufflePowerUps = 1; // Reset power-ups
    hammerPowerUps = 1;

    // Re-define collection targets for this level
    if (level % 2 === 0) {
        const colorCount = level <= COLOR_SETS.length ? COLOR_SETS[level-1] : 6;
        const targetColor = getRandomInt(0, colorCount - 1);
        const targetAmount = 10 + Math.floor(level / 2) * 5;
        targetCollect[targetColor] = targetAmount;
    } else if (level % 3 === 0) {
        const targetCollectibleType = getRandomInt(0, COLLECTIBLE_SHAPES.length - 1);
        const targetAmount = 3 + Math.floor(level / 3) * 1;
        targetCollect[targetCollectibleType] = targetAmount;
    }

    initGrid();
    renderGrid();
    updateButtons(true);
    updateUIElements();
    targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
    showMessage(`Level ${level} diulang! Semangat!`);
    updateCollectTargetUI();
    if (isMusicPlaying) {
        backgroundMusic.play();
    }
  }

  function toggleMusic() {
    if (backgroundMusic.paused) {
      backgroundMusic.play().then(() => {
        isMusicPlaying = true;
        musicIcon.textContent = 'music_note';
        localStorage.setItem('musicState', 'playing');
      }).catch(error => {
        console.warn("Autoplay prevented:", error);
        isMusicPlaying = false;
        musicIcon.textContent = 'music_off';
        localStorage.setItem('musicState', 'paused');
      });
    } else {
      backgroundMusic.pause();
      isMusicPlaying = false;
      musicIcon.textContent = 'music_off';
      localStorage.setItem('musicState', 'paused');
    }
  }

  // New: Function to toggle sound effects
  function toggleSoundEffect() {
    isSoundEffectOn = !isSoundEffectOn;
    if (isSoundEffectOn) {
      soundIcon.textContent = 'volume_up';
      localStorage.setItem('soundState', 'on');
    } else {
      soundIcon.textContent = 'volume_off';
      localStorage.setItem('soundState', 'off');
    }
  }

  function updateCollectTargetUI() {
      collectTargetElement.innerHTML = '';
      if (Object.keys(targetCollect).length > 0) {
          collectTargetElement.style.display = 'flex';
          for (const key in targetCollect) {
              if (targetCollect.hasOwnProperty(key)) {
                  const required = targetCollect[key];
                  const collected = currentCollected[key] || 0;
                  const itemDisplay = ITEM_SHAPES[key] || COLLECTIBLE_SHAPES[key]; // Determine if it's a normal item or collectible
                  const itemDiv = document.createElement('div');
                  itemDiv.classList.add('collect-item');
                  itemDiv.innerHTML = `<span class="icon">${itemDisplay}</span> <span class="count">${collected}/${required}</span>`;
                  collectTargetElement.appendChild(itemDiv);
              }
          }
      } else {
          collectTargetElement.style.display = 'none';
      }
  }

  function updatePowerUpButtons() {
      shuffleCountSpan.textContent = shufflePowerUps;
      hammerCountSpan.textContent = hammerPowerUps;
      shuffleBtn.disabled = shufflePowerUps <= 0 || isAnimating || isPaused;
      hammerBtn.disabled = hammerPowerUps <= 0 || isAnimating || isPaused;
  }

  async function useShuffle() {
      if (shufflePowerUps <= 0 || isAnimating || isPaused) return;
      if (!confirm("Gunakan Acak? Ini akan mengocok ulang papan.")) return;

      playSound(powerUpSound);
      shufflePowerUps--;
      updatePowerUpButtons();
      isAnimating = true;
      showMessage("Mengocok ulang papan...", false);

      // Simple shuffle: re-initialize grid
      initGrid();
      renderGrid();
      await delay(500); // Animation delay for shuffle
      isAnimating = false;
      checkLevelCompletion(); // Re-check for possible moves
  }

  async function useHammer(index) {
      if (hammerPowerUps <= 0 || isAnimating || isPaused) return;
      if (index === undefined) { // If called without an index, activate selection mode
          showMessage("Pilih item untuk dihancurkan dengan palu.", false);
          activePowerUp = 'hammer';
          renderGrid(); // Highlight selected cell if any
          return;
      }

      playSound(powerUpSound);
      hammerPowerUps--;
      updatePowerUpButtons();
      isAnimating = true;
      showMessage("Palu digunakan!", false);

      const cell = detailedGrid[index];
      const cellsToClear = new Set();
      const cellsToHit = new Set();

      if (cell.type === CELL_TYPES.NORMAL) {
          cellsToClear.add(index);
      } else if (cell.type === CELL_TYPES.ICE) {
          cellsToHit.add(index);
      } else if (cell.type === CELL_TYPES.COLLECTIBLE) {
          cellsToClear.add(index);
      }

      // Apply damage to ice blocks
      cellsToHit.forEach(i => {
          if (detailedGrid[i].type === CELL_TYPES.ICE) {
              detailedGrid[i].hits--;
              playSound(blockHitSound);
              if (detailedGrid[i].hits <= 0) {
                  cellsToClear.add(i);
              }
          }
      });

      score += cellsToClear.size * 10; // Score for destroyed items
      scoreIndicator.querySelector('.status-value').textContent = score;

      cellsToClear.forEach(i => {
          const cell = detailedGrid[i];
          if (cell.type === CELL_TYPES.NORMAL) {
              currentCollected[cell.color] = (currentCollected[cell.color] || 0) + 1;
          } else if (cell.type === CELL_TYPES.COLLECTIBLE) {
              currentCollected[cell.collectibleType] = (currentCollected[cell.collectibleType] || 0) + 1;
          }
          const domCell = gridElement.children[i];
          if(domCell){
              domCell.classList.add('removing');
          }
      });
      updateCollectTargetUI();

      await delay(400);
      cellsToClear.forEach(i => {
          detailedGrid[i] = { type: CELL_TYPES.NORMAL, color: -1, bonus: BONUS_TYPES.NONE, hits: 0 };
      });
      await dropCandies();
      refillGrid();
      renderGrid();
      await delay(300);
      isAnimating = false;
      checkLevelCompletion();
  }

  // Modal functions
  function showModal(title, message, buttonText) {
      modalTitle.textContent = title;
      modalMessage.textContent = message;
      modalActionBtn.textContent = buttonText;
      gameModal.classList.add('active');
      modalActionBtn.onclick = () => {
          gameModal.classList.remove('active');
          if (buttonText === "Lanjut Level") {
              startNextLevel();
          } else if (buttonText === "Coba Lagi") {
              retryLevel();
          } else if (buttonText === "Mulai Ulang") {
              startGame();
          }
      };
  }

  // Function to check for possible moves (considering all cell types)
  function hasPossibleMoves() {
      const tempGrid = detailedGrid.map(cell => ({ ...cell }));

      // This findMatches is a local version that operates on tempGrid
      const findMatchesInTempGrid = (gridToSearch) => {
          const matches = new Set();
          // Check horizontal
          for (let r = 0; r < ROWS; r++) {
              for (let c = 0; c < COLS - 2; c++) {
                  if (gridToSearch[idx(r, c)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r, c + 1)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r, c + 2)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r, c)].color === gridToSearch[idx(r, c + 1)].color &&
                      gridToSearch[idx(r, c + 1)].color === gridToSearch[idx(r, c + 2)].color) {
                      matches.add(idx(r, c)); matches.add(idx(r, c + 1)); matches.add(idx(r, c + 2));
                  }
              }
          }
          // Check vertical
          for (let c = 0; c < COLS; c++) {
              for (let r = 0; r < ROWS - 2; r++) {
                  if (gridToSearch[idx(r, c)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r + 1, c)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r + 2, c)].type === CELL_TYPES.NORMAL &&
                      gridToSearch[idx(r, c)].color === gridToSearch[idx(r + 1, c)].color &&
                      gridToSearch[idx(r + 1, c)].color === gridToSearch[idx(r + 2, c)].color) {
                      matches.add(idx(r, c)); matches.add(idx(r + 1, c)); matches.add(idx(r + 2, c));
                  }
              }
          }
          return Array.from(matches);
      };

      for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
              const currentIdx = idx(r, c);
              if (tempGrid[currentIdx].type !== CELL_TYPES.NORMAL) continue; // Only normal items can be swapped

              // Try swapping with right neighbor
              if (c + 1 < COLS && tempGrid[idx(r, c + 1)].type === CELL_TYPES.NORMAL) {
                  const rightIdx = idx(r, c + 1);
                  // Perform a shallow copy of cells for the swap to avoid modifying tempGrid directly
                  const cell1 = tempGrid[currentIdx];
                  const cell2 = tempGrid[rightIdx];
                  tempGrid[currentIdx] = cell2;
                  tempGrid[rightIdx] = cell1;

                  if (findMatchesInTempGrid(tempGrid).length > 0) {
                      return true;
                  }
                  // Swap back
                  tempGrid[currentIdx] = cell1;
                  tempGrid[rightIdx] = cell2;
              }

              // Try swapping with bottom neighbor
              if (r + 1 < ROWS && tempGrid[idx(r + 1, c)].type === CELL_TYPES.NORMAL) {
                  const downIdx = idx(r + 1, c);
                  // Perform a shallow copy of cells for the swap to avoid modifying tempGrid directly
                  const cell1 = tempGrid[currentIdx];
                  const cell2 = tempGrid[downIdx];
                  tempGrid[currentIdx] = cell2;
                  tempGrid[downIdx] = cell1;

                  if (findMatchesInTempGrid(tempGrid).length > 0) {
                      return true;
                  }
                  // Swap back
                  tempGrid[currentIdx] = cell1;
                  tempGrid[downIdx] = cell2;
              }
          }
      }
      return false;
  }


  // Event listeners
  startBtn.addEventListener('click', () => startGame());
  pauseBtn.addEventListener('click', () => pauseGame());
  retryBtn.addEventListener('click', () => {
    if(confirm('Ulangi level ini? Skor dan target akan direset.')) retryLevel();
  });
  musicControlBtn.addEventListener('click', toggleMusic);
  soundControlBtn.addEventListener('click', toggleSoundEffect); // New event listener
  shuffleBtn.addEventListener('click', useShuffle);
  hammerBtn.addEventListener('click', () => useHammer()); // Activate hammer selection mode

  gridElement.addEventListener('keydown', e => {
    if(isAnimating || isPaused) return;
    const focus = document.activeElement;
    if(!focus.classList.contains('cell')) return;
    const currentIndex = Number(focus.dataset.index);
    let targetIndex = null;
    switch(e.key){
      case 'ArrowUp': if(currentIndex - COLS >= 0) targetIndex = currentIndex - COLS; break;
      case 'ArrowDown': if(currentIndex + COLS < detailedGrid.length) targetIndex = currentIndex + COLS; break;
      case 'ArrowLeft': if(currentIndex % COLS !== 0) targetIndex = currentIndex - 1; break;
      case 'ArrowRight': if(currentIndex % COLS !== COLS - 1) targetIndex = currentIndex + 1; break;
      case 'Enter':
      case ' ': onCellClicked(currentIndex); e.preventDefault(); break;
    }
    if(targetIndex !== null){
      gridElement.children[targetIndex].focus();
      e.preventDefault();
    }
  });

  // Initial setup
  updateButtons(false);
  movesIndicator.querySelector('.status-label').textContent = 'GERAKAN';

  const savedMaxLevel = localStorage.getItem('fruitCrushMaxLevel');
  if (savedMaxLevel) {
      level = parseInt(savedMaxLevel);
      maxMoves = BASE_MOVES + (level * 3);
      if(level % 5 === 0) maxMoves += 10;
      moves = maxMoves;
      targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
      showMessage(`Lanjutkan dari Level ${level}! Tekan Mulai.`, false);
  } else {
      targetScoreIndicator.querySelector('.status-value').textContent = level * 500;
      showMessage("Tekan Mulai untuk bermain FRUIT CRUSH!");
  }
  updateUIElements();
  updateCollectTargetUI();
  updatePowerUpButtons();

  // Load music state from localStorage
  const savedMusicState = localStorage.getItem('musicState');
  if (savedMusicState === 'playing') {
    backgroundMusic.play().then(() => {
        isMusicPlaying = true;
        musicIcon.textContent = 'music_note';
    }).catch(error => {
        console.warn("Autoplay prevented on load. Music will start after user interaction.", error);
        isMusicPlaying = false;
        musicIcon.textContent = 'music_off';
        localStorage.setItem('musicState', 'paused');
    });
  } else {
    isMusicPlaying = false;
    musicIcon.textContent = 'music_off';
  }

  // New: Load sound effect state from localStorage
  const savedSoundState = localStorage.getItem('soundState');
  if (savedSoundState === 'off') {
      isSoundEffectOn = false;
      soundIcon.textContent = 'volume_off';
  } else {
      isSoundEffectOn = true;
      soundIcon.textContent = 'volume_up';
  }

})();
</script>
</body>
</html>
